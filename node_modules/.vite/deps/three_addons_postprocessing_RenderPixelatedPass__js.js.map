{
  "version": 3,
  "sources": ["../../three/examples/jsm/postprocessing/RenderPixelatedPass.js"],
  "sourcesContent": ["import {\n\tWebGLRenderTarget,\n\tMeshNormalMaterial,\n\tShaderMaterial,\n\tVector2,\n\tVector4,\n\tDepthTexture,\n\tNearestFilter,\n\tHalfFloatType\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\n/**\n * A special type of render pass that produces a pixelated beauty pass.\n *\n * ```js\n * const renderPixelatedPass = new RenderPixelatedPass( 6, scene, camera );\n * composer.addPass( renderPixelatedPass );\n * ```\n *\n * @augments Pass\n * @three_import import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';\n */\nclass RenderPixelatedPass extends Pass {\n\n\t/**\n\t * Constructs a new render pixelated pass.\n\t *\n\t * @param {number} pixelSize - The effect's pixel size.\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera.\n\t * @param {{normalEdgeStrength:number,depthEdgeStrength:number}} options - The pass options.\n\t */\n\tconstructor( pixelSize, scene, camera, options = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The effect's pixel size.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.pixelSize = pixelSize;\n\n\t\t/**\n\t\t * The scene to render.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The normal edge strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.3\n\t\t */\n\t\tthis.normalEdgeStrength = options.normalEdgeStrength || 0.3;\n\n\t\t/**\n\t\t * The normal edge strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.4\n\t\t */\n\t\tthis.depthEdgeStrength = options.depthEdgeStrength || 0.4;\n\n\t\t/**\n\t\t * The pixelated material.\n\t\t *\n\t\t * @type {ShaderMaterial}\n\t\t */\n\t\tthis.pixelatedMaterial = this._createPixelatedMaterial();\n\n\t\t// internals\n\n\t\tthis._resolution = new Vector2();\n\t\tthis._renderResolution = new Vector2();\n\n\t\tthis._normalMaterial = new MeshNormalMaterial();\n\n\t\tthis._beautyRenderTarget = new WebGLRenderTarget();\n\t\tthis._beautyRenderTarget.texture.minFilter = NearestFilter;\n\t\tthis._beautyRenderTarget.texture.magFilter = NearestFilter;\n\t\tthis._beautyRenderTarget.texture.type = HalfFloatType;\n\t\tthis._beautyRenderTarget.depthTexture = new DepthTexture();\n\n\t\tthis._normalRenderTarget = new WebGLRenderTarget();\n\t\tthis._normalRenderTarget.texture.minFilter = NearestFilter;\n\t\tthis._normalRenderTarget.texture.magFilter = NearestFilter;\n\t\tthis._normalRenderTarget.texture.type = HalfFloatType;\n\n\t\tthis._fsQuad = new FullScreenQuad( this.pixelatedMaterial );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._beautyRenderTarget.dispose();\n\t\tthis._normalRenderTarget.dispose();\n\n\t\tthis.pixelatedMaterial.dispose();\n\t\tthis._normalMaterial.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._resolution.set( width, height );\n\t\tthis._renderResolution.set( ( width / this.pixelSize ) | 0, ( height / this.pixelSize ) | 0 );\n\t\tconst { x, y } = this._renderResolution;\n\t\tthis._beautyRenderTarget.setSize( x, y );\n\t\tthis._normalRenderTarget.setSize( x, y );\n\t\tthis._fsQuad.material.uniforms.resolution.value.set( x, y, 1 / x, 1 / y );\n\n\t}\n\n\t/**\n\t * Sets the effect's pixel size.\n\t *\n\t * @param {number} pixelSize - The pixel size to set.\n\t */\n\tsetPixelSize( pixelSize ) {\n\n\t\tthis.pixelSize = pixelSize;\n\t\tthis.setSize( this._resolution.x, this._resolution.y );\n\n\t}\n\n\t/**\n\t * Performs the pixelation pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer/*, readBuffer , deltaTime, maskActive */ ) {\n\n\t\tconst uniforms = this._fsQuad.material.uniforms;\n\t\tuniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n\t\tuniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n\n\t\trenderer.setRenderTarget( this._beautyRenderTarget );\n\t\trenderer.render( this.scene, this.camera );\n\n\t\tconst overrideMaterial_old = this.scene.overrideMaterial;\n\t\trenderer.setRenderTarget( this._normalRenderTarget );\n\t\tthis.scene.overrideMaterial = this._normalMaterial;\n\t\trenderer.render( this.scene, this.camera );\n\t\tthis.scene.overrideMaterial = overrideMaterial_old;\n\n\t\tuniforms.tDiffuse.value = this._beautyRenderTarget.texture;\n\t\tuniforms.tDepth.value = this._beautyRenderTarget.depthTexture;\n\t\tuniforms.tNormal.value = this._normalRenderTarget.texture;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\n\t\t\tif ( this.clear ) renderer.clear();\n\n\t\t}\n\n\t\tthis._fsQuad.render( renderer );\n\n\t}\n\n\t// internals\n\n\t_createPixelatedMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\ttDiffuse: { value: null },\n\t\t\t\ttDepth: { value: null },\n\t\t\t\ttNormal: { value: null },\n\t\t\t\tresolution: { value: new Vector4() },\n\t\t\t\tnormalEdgeStrength: { value: 0 },\n\t\t\t\tdepthEdgeStrength: { value: 0 }\n\t\t\t},\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0)\n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0;\n\t\t\t\t\tif (normalEdgeStrength > 0.0)\n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t`\n\t\t} );\n\n\t}\n\n}\n\nexport { RenderPixelatedPass };\n"],
  "mappings": "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",
  "names": []
}
